#!/bin/bash

# Unified Workflow Release CLI
# A comprehensive release tool for all Unified Workflow components
# Usage: ./release [component] [options]

set -e

# Configuration
VERSION_FILE="VERSION"
DEFAULT_REGISTRY="uwf-application"
COMPONENTS=("sdk" "registry" "executor" "worker" "all")
RELEASE_DIR="release"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Functions
print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

print_step() {
    echo -e "${CYAN}=== $1 ===${NC}"
}

print_header() {
    echo -e "${MAGENTA}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë               Unified Workflow Release CLI               ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
}

# Read current version
read_current_version() {
    if [ -f "$VERSION_FILE" ]; then
        CURRENT_VERSION=$(cat "$VERSION_FILE")
        echo "$CURRENT_VERSION"
    else
        echo "v1.0.0"
    fi
}

# Parse semantic version
parse_version() {
    local version=$1
    if [[ $version =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
        MAJOR=${BASH_REMATCH[1]}
        MINOR=${BASH_REMATCH[2]}
        PATCH=${BASH_REMATCH[3]}
        echo "$MAJOR $MINOR $PATCH"
    else
        print_error "Invalid version format: $version. Expected format: vX.Y.Z"
        exit 1
    fi
}

# Increment version
increment_version() {
    local version=$1
    local increment_type=$2
    
    read -r MAJOR MINOR PATCH <<< "$(parse_version "$version")"
    
    case $increment_type in
        major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
        minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
        patch)
            PATCH=$((PATCH + 1))
            ;;
        *)
            print_error "Invalid increment type: $increment_type. Use: major, minor, or patch"
            exit 1
            ;;
    esac
    
    echo "v${MAJOR}.${MINOR}.${PATCH}"
}

# Update version file
update_version_file() {
    local new_version=$1
    echo "$new_version" > "$VERSION_FILE"
    print_success "Updated version file to: $new_version"
}

# Check prerequisites
check_prerequisites() {
    print_step "Checking Prerequisites"
    
    local missing_deps=()
    
    # Check Docker
    if ! command -v docker >/dev/null 2>&1; then
        missing_deps+=("docker")
    else
        print_success "Docker is installed"
    fi
    
    # Check Go
    if ! command -v go >/dev/null 2>&1; then
        print_warning "Go is not installed (needed for tests and builds)"
    else
        print_success "Go is installed"
    fi
    
    # Check git
    if ! command -v git >/dev/null 2>&1; then
        print_warning "Git is not installed"
    else
        print_success "Git is installed"
    fi
    
    # Check GitHub CLI (optional)
    if command -v gh >/dev/null 2>&1; then
        print_success "GitHub CLI (gh) is installed"
    else
        print_warning "GitHub CLI (gh) is not installed (GitHub releases will require manual steps)"
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_error "Missing required dependencies: ${missing_deps[*]}"
        exit 1
    fi
}

# Run tests
run_tests() {
    print_step "Running Tests"
    
    if command -v go >/dev/null 2>&1; then
        echo "Running Go tests with timeout..."
        
        # Create a test runner script with timeout
        local test_script=$(mktemp)
        cat > "$test_script" << 'EOF'
#!/bin/bash
set -e

# Run go test with timeout handling
echo "Running: go test ./... -short"
go test ./... -short 2>&1
EOF
        
        chmod +x "$test_script"
        
        # Cross-platform timeout implementation
        local timeout_occurred=0
        
        if command -v gtimeout >/dev/null 2>&1; then
            # macOS with coreutils
            if gtimeout 30s bash "$test_script"; then
                print_success "All tests passed"
            else
                local exit_code=$?
                if [ $exit_code -eq 124 ]; then
                    print_warning "Tests timed out after 30 seconds (continuing anyway)"
                    timeout_occurred=1
                else
                    print_warning "Some tests failed (exit code: $exit_code) (continuing anyway)"
                fi
            fi
        elif command -v timeout >/dev/null 2>&1; then
            # Linux timeout
            if timeout 30s bash "$test_script"; then
                print_success "All tests passed"
            else
                local exit_code=$?
                if [ $exit_code -eq 124 ]; then
                    print_warning "Tests timed out after 30 seconds (continuing anyway)"
                    timeout_occurred=1
                else
                    print_warning "Some tests failed (exit code: $exit_code) (continuing anyway)"
                fi
            fi
        elif command -v perl >/dev/null 2>&1; then
            # Use perl for timeout on macOS without coreutils
            print_info "Using perl for timeout (30 seconds)..."
            if perl -e 'alarm 30; exec @ARGV' bash "$test_script"; then
                print_success "All tests passed"
            else
                local exit_code=$?
                if [ $exit_code -eq 142 ]; then
                    print_warning "Tests timed out after 30 seconds (continuing anyway)"
                    timeout_occurred=1
                else
                    print_warning "Some tests failed (exit code: $exit_code) (continuing anyway)"
                fi
            fi
        else
            # No timeout available, run with warning and background process
            print_warning "No timeout command available, running tests with background timeout..."
            echo "Note: Tests may hang. Press Ctrl+C to skip if they take too long."
            echo "      Install 'coreutils' for timeout support: brew install coreutils"
            
            # Run tests in background with timeout
            (bash "$test_script") &
            local test_pid=$!
            
            # Wait for 30 seconds
            sleep 30
            
            # Check if process is still running
            if kill -0 $test_pid 2>/dev/null; then
                print_warning "Tests taking too long, killing process (continuing anyway)"
                kill -9 $test_pid 2>/dev/null || true
                timeout_occurred=1
            else
                # Process completed, wait for it to get exit code
                wait $test_pid && print_success "All tests passed" || print_warning "Some tests failed (continuing anyway)"
            fi
        fi
        
        # Clean up
        rm -f "$test_script"
        
        # If timeout occurred, skip further test attempts
        if [ $timeout_occurred -eq 1 ]; then
            return 0
        fi
        
    else
        print_warning "Skipping tests (Go not installed)"
    fi
}

# Release SDK component
release_sdk() {
    local version=$1
    print_step "Releasing SDK $version"
    
    # Check if package_sdk.sh exists
    if [ ! -f "package_sdk.sh" ]; then
        print_error "package_sdk.sh not found"
        return 1
    fi
    
    # package_sdk.sh expects version without 'v' prefix
    local version_without_v="${version#v}"
    
    # Run SDK packaging script
    echo "Packaging SDK with version: $version_without_v"
    if ./package_sdk.sh "$version_without_v"; then
        print_success "SDK packaged successfully"
    else
        print_error "Failed to package SDK"
        return 1
    fi
    
    # Create SDK release bundle
    local sdk_bundle="dist/unified-workflow-sdk-${version}.tar.gz"
    if [ -f "$sdk_bundle" ]; then
        print_success "SDK release bundle created: $sdk_bundle"
        echo "  Size: $(du -h "$sdk_bundle" | cut -f1)"
    else
        # Try alternative name (package_sdk.sh might create with v prefix)
        local alt_sdk_bundle="dist/unified-workflow-sdk-${version_without_v}.tar.gz"
        if [ -f "$alt_sdk_bundle" ]; then
            # Rename to expected name
            mv "$alt_sdk_bundle" "$sdk_bundle"
            print_success "SDK release bundle created (renamed): $sdk_bundle"
            echo "  Size: $(du -h "$sdk_bundle" | cut -f1)"
        else
            print_error "SDK release bundle not found: $sdk_bundle"
            print_error "Also checked: $alt_sdk_bundle"
            return 1
        fi
    fi
    
    return 0
}

# Release Docker component
release_docker_component() {
    local component=$1
    local version=$2
    local registry=$3
    
    print_step "Releasing $component $version"
    
    # Check Dockerfile
    local dockerfile="Dockerfile.$component"
    if [ ! -f "$dockerfile" ]; then
        print_error "Dockerfile not found: $dockerfile"
        return 1
    fi
    
    # Build Docker image
    local image_name="${registry}/uwf-${component}:${version}"
    local latest_image_name="${registry}/uwf-${component}:latest"
    
    echo "Building Docker image: $image_name"
    if docker build -t "$image_name" -f "$dockerfile" .; then
        print_success "Built $component image: $image_name"
        
        # Tag as latest
        docker tag "$image_name" "$latest_image_name"
        print_success "Tagged as latest: $latest_image_name"
    else
        print_error "Failed to build $component image"
        return 1
    fi
    
    return 0
}

# Build binaries for a component
build_component_binary() {
    local component=$1
    local version=$2
    
    print_step "Building $component binary"
    
    local bin_dir="dist/binaries-${version}"
    mkdir -p "$bin_dir"
    
    case $component in
        registry)
            local source_dir="./cmd/registry-api"
            local binary_name="registry-service"
            ;;
        executor)
            local source_dir="./cmd/executor-api"
            local binary_name="executor-service"
            ;;
        worker)
            local source_dir="./cmd/workflow-worker"
            local binary_name="workflow-worker"
            ;;
        *)
            print_error "Unknown component for binary build: $component"
            return 1
            ;;
    esac
    
    if [ ! -d "$source_dir" ]; then
        print_error "Source directory not found: $source_dir"
        return 1
    fi
    
    echo "Building $component binary from $source_dir..."
    if go build -o "$bin_dir/$binary_name" "$source_dir"; then
        print_success "Built $component binary: $bin_dir/$binary_name"
    else
        print_error "Failed to build $component binary"
        return 1
    fi
    
    return 0
}

# Create release bundle
create_release_bundle() {
    local version=$1
    local registry=$2
    
    print_step "Creating Release Bundle"
    
    local bundle_name="unified-workflow-stack-${version}"
    local bundle_dir="$RELEASE_DIR/${version}"
    
    # Clean and create directory
    rm -rf "$bundle_dir"
    mkdir -p "$bundle_dir"
    
    # Copy essential files
    echo "Copying configuration files..."
    cp docker-compose.yml "$bundle_dir/"
    cp README.md "$bundle_dir/"
    
    # Create version-specific docker-compose file
    echo "Creating versioned docker-compose file..."
    sed "s|build:|image: ${registry}/uwf-|g" docker-compose.yml | \
    sed "s|context: .||g" | \
    sed "s|dockerfile: Dockerfile.registry|registry:${version}|g" | \
    sed "s|dockerfile: Dockerfile.executor|executor:${version}|g" | \
    sed "s|dockerfile: Dockerfile.worker|worker:${version}|g" > "$bundle_dir/docker-compose.${version}.yml"
    
    # Create deployment guide
    cat > "$bundle_dir/DEPLOYMENT.md" << EOF
# Unified Workflow ${version} - Deployment Guide

## Quick Start

### Using Docker Compose
\`\`\`bash
# Download and extract the release bundle
tar -xzf ${bundle_name}.tar.gz
cd ${bundle_name}

# Start all services
docker-compose -f docker-compose.${version}.yml up -d
\`\`\`

### Using Docker Images Directly
\`\`\`bash
# Pull the images
docker pull ${registry}/uwf-registry:${version}
docker pull ${registry}/uwf-executor:${version}
docker pull ${registry}/uwf-worker:${version}

# Run individually
docker run -d -p 8080:8080 --name uwf-registry ${registry}/uwf-registry:${version}
docker run -d -p 8081:8081 --name uwf-executor ${registry}/uwf-executor:${version}
docker run -d --name uwf-worker ${registry}/uwf-worker:${version}
\`\`\`

## Service Ports

- **Registry Service**: 8080
- **Executor Service**: 8081
- **Worker Service**: No exposed ports (consumes from NATS)

## Health Checks

- Registry: http://localhost:8080/health
- Executor: http://localhost:8081/health

## Support

For issues and questions, please refer to:
- GitHub: https://github.com/uwf-application/unified-workflow
- Documentation: Included in release bundle
EOF
    
    # Create bundle archive
    echo "Creating bundle archive..."
    tar -czf "${bundle_name}.tar.gz" -C "$RELEASE_DIR" "$version"
    
    print_success "Created release bundle: ${bundle_name}.tar.gz"
    print_success "Bundle size: $(du -h "${bundle_name}.tar.gz" | cut -f1)"
    
    # Create checksum
    shasum -a 256 "${bundle_name}.tar.gz" > "${bundle_name}.sha256"
    print_success "Created checksum: ${bundle_name}.sha256"
}

# Create binaries archive
create_binaries_archive() {
    local version=$1
    
    print_step "Creating Binaries Archive"
    
    local bin_dir="dist/binaries-${version}"
    local archive_name="dist/unified-workflow-binaries-${version}.tar.gz"
    
    if [ -d "$bin_dir" ]; then
        echo "Creating binaries archive from $bin_dir..."
        tar -czf "$archive_name" -C "$bin_dir" .
        
        print_success "Created binaries archive: $archive_name"
        print_success "Archive size: $(du -h "$archive_name" | cut -f1)"
        
        # Create checksum
        shasum -a 256 "$archive_name" > "${archive_name}.sha256"
        print_success "Created binaries checksum: ${archive_name}.sha256"
    else
        print_warning "Binaries directory not found: $bin_dir (skipping binaries archive)"
    fi
}

# Push Docker images to registry
push_docker_images() {
    local components=$1
    local version=$2
    local registry=$3
    
    print_step "Pushing Docker Images to Registry"
    
    read -p "Do you want to push images to registry? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_warning "Skipping image push"
        return 0
    fi
    
    echo "Pushing images to registry: $registry"
    
    for component in $components; do
        if [ "$component" == "sdk" ]; then
            continue  # SDK doesn't have Docker image
        fi
        
        local image_name="${registry}/uwf-${component}:${version}"
        local latest_image_name="${registry}/uwf-${component}:latest"
        
        echo "Pushing ${component} image..."
        if docker push "$image_name"; then
            print_success "Pushed: $image_name"
        else
            print_error "Failed to push: $image_name"
            print_warning "Make sure you're logged into the registry: docker login"
            return 1
        fi
        
        if docker push "$latest_image_name"; then
            print_success "Pushed: $latest_image_name"
        fi
    done
    
    return 0
}

# Create git tag
create_git_tag() {
    local version=$1
    
    print_step "Creating Git Tag"
    
    if ! command -v git >/dev/null 2>&1; then
        print_warning "Git not installed (skipping tag creation)"
        return 0
    fi
    
    # Check if tag already exists
    if git rev-parse "$version" >/dev/null 2>&1; then
        print_warning "Git tag $version already exists"
        read -p "Do you want to delete and recreate it? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git tag -d "$version"
            git push origin --delete "$version" 2>/dev/null || true
        else
            return 0
        fi
    fi
    
    # Create tag
    echo "Creating git tag: $version"
    git tag -a "$version" -m "Release $version"
    
    # Push tag
    read -p "Do you want to push the tag to remote? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git push origin "$version"
        print_success "Pushed tag to remote: $version"
    else
        print_warning "Tag created locally but not pushed to remote"
    fi
    
    return 0
}

# Create GitHub release
create_github_release() {
    local version=$1
    
    print_step "Creating GitHub Release"
    
    if ! command -v gh >/dev/null 2>&1; then
        print_warning "GitHub CLI (gh) not installed (skipping GitHub release)"
        echo ""
        echo "Manual steps required:"
        echo "1. Go to: https://github.com/uwf-application/unified-workflow/releases/new"
        echo "2. Select tag: $version"
        echo "3. Title: Unified Workflow $version"
        echo "4. Upload release artifacts"
        echo "5. Publish release"
        return 0
    fi
    
    # Check if release already exists
    if gh release view "$version" >/dev/null 2>&1; then
        print_warning "GitHub release $version already exists"
        read -p "Do you want to delete and recreate it? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            gh release delete "$version" --yes
        else
            return 0
        fi
    fi
    
    # Collect release artifacts
    local artifacts=()
    
    # SDK bundle
    local sdk_bundle="dist/unified-workflow-sdk-${version}.tar.gz"
    if [ -f "$sdk_bundle" ]; then
        artifacts+=("$sdk_bundle")
    fi
    
    # Stack bundle
    local stack_bundle="unified-workflow-stack-${version}.tar.gz"
    if [ -f "$stack_bundle" ]; then
        artifacts+=("$stack_bundle")
    fi
    
    # Binaries archive
    local binaries_archive="dist/unified-workflow-binaries-${version}.tar.gz"
    if [ -f "$binaries_archive" ]; then
        artifacts+=("$binaries_archive")
    fi
    
    # Checksum files
    for artifact in "${artifacts[@]}"; do
        local checksum_file="${artifact}.sha256"
        if [ -f "$checksum_file" ]; then
            artifacts+=("$checksum_file")
        fi
    done
    
    if [ ${#artifacts[@]} -eq 0 ]; then
        print_warning "No release artifacts found (skipping GitHub release)"
        return 0
    fi
    
    # Read release notes
    local release_notes=""
    if [ -f "RELEASE_CHECKLIST.md" ]; then
        release_notes=$(cat "RELEASE_CHECKLIST.md" | sed -n '/## üìù Release Notes/,/## üîß Support Information/p' | head -n -1 2>/dev/null || echo "Release $version")
    else
        release_notes="Release $version - Unified Workflow"
    fi
    
    # Create release
    echo "Creating GitHub release: $version"
    echo "Artifacts: ${artifacts[*]}"
    
    if gh release create "$version" \
        --title "Unified Workflow $version" \
        --notes "$release_notes" \
        "${artifacts[@]}"; then
        print_success "GitHub release created: $version"
    else
        print_error "Failed to create GitHub release"
        return 1
    fi
    
    return 0
}

# Clean release artifacts
clean_release_artifacts() {
    print_step "Cleaning Release Artifacts"
    
    echo "This will remove all release artifacts including:"
    echo "  - dist/ directory (SDK bundles, binaries)"
    echo "  - release/ directory (release bundles)"
    echo "  - Docker images (uwf-application/uwf-*)"
    echo "  - Local git tags (not remote)"
    echo ""
    
    read -p "Are you sure you want to clean all release artifacts? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_warning "Clean cancelled by user"
        return 0
    fi
    
    # Clean dist directory
    if [ -d "dist" ]; then
        echo "Removing dist/ directory..."
        rm -rf dist/
        print_success "Removed dist/ directory"
    else
        print_info "dist/ directory not found"
    fi
    
    # Clean release directory
    if [ -d "$RELEASE_DIR" ]; then
        echo "Removing $RELEASE_DIR/ directory..."
        rm -rf "$RELEASE_DIR"/
        print_success "Removed $RELEASE_DIR/ directory"
    else
        print_info "$RELEASE_DIR/ directory not found"
    fi
    
    # Clean release bundle files
    echo "Removing release bundle files..."
    rm -f unified-workflow-stack-*.tar.gz unified-workflow-stack-*.sha256 2>/dev/null || true
    print_success "Removed release bundle files"
    
    # Remove local Docker images
    echo "Removing local Docker images..."
    for component in "${COMPONENTS[@]}"; do
        if [ "$component" != "sdk" ] && [ "$component" != "all" ]; then
            # Remove by image name
            docker rmi "$DEFAULT_REGISTRY/uwf-$component:latest" 2>/dev/null || true
            docker rmi "$DEFAULT_REGISTRY/uwf-$component" 2>/dev/null || true
            
            # Remove any images with version tags
            for img in $(docker images --format "{{.Repository}}:{{.Tag}}" | grep "uwf-$component" 2>/dev/null || true); do
                docker rmi "$img" 2>/dev/null || true
            done
        fi
    done
    print_success "Removed local Docker images"
    
    # Remove local git tags (ask for confirmation)
    if command -v git >/dev/null 2>&1; then
        read -p "Remove local git tags? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Removing local git tags..."
            git tag -l | xargs git tag -d 2>/dev/null || true
            print_success "Removed local git tags"
        else
            print_info "Skipping git tag removal"
        fi
    fi
    
    print_success "Cleanup complete!"
    echo ""
    echo "Remaining items (not removed):"
    echo "  - Remote git tags (use: git push origin --delete <tag>)"
    echo "  - Remote Docker images (delete from registry)"
    echo "  - GitHub releases (delete manually from GitHub)"
    echo "  - VERSION file (preserved)"
    echo ""
}

# Show help
show_help() {
    print_header
    echo ""
    echo "Usage: ./release [COMMAND] [COMPONENT] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  release    Create a release (default command)"
    echo "  clean      Clean all release artifacts"
    echo ""
    echo "Components (for release command):"
    echo "  sdk         Release the Unified Workflow SDK"
    echo "  registry    Release the Registry Service"
    echo "  executor    Release the Executor Service"
    echo "  worker      Release the Worker Service"
    echo "  all         Release all components (default)"
    echo ""
    echo "Options (for release command):"
    echo "  -h, --help              Show this help message"
    echo "  -v, --version VERSION   Use specific version (default: auto-increment)"
    echo "  -i, --increment TYPE    Increment type: major, minor, patch (default: minor)"
    echo "  -r, --registry REG      Docker registry (default: $DEFAULT_REGISTRY)"
    echo "  --no-tests              Skip running tests"
    echo "  --no-tag                Skip creating git tag"
    echo "  --no-github             Skip creating GitHub release"
    echo "  --no-push               Skip pushing Docker images"
    echo "  --dry-run               Show what would be done without executing"
    echo ""
    echo "Examples:"
    echo "  ./release                     # Release all components with auto-incremented version"
    echo "  ./release sdk                 # Release only the SDK"
    echo "  ./release all -i major        # Release all with major version increment"
    echo "  ./release registry -v v1.2.3  # Release registry with specific version"
    echo "  ./release --dry-run           # Show release plan without executing"
    echo "  ./release clean               # Clean all release artifacts"
    echo ""
    echo "Version Management:"
    echo "  Current version is read from: $VERSION_FILE"
    echo "  Version format: vMAJOR.MINOR.PATCH (e.g., v1.0.0)"
    echo "  Auto-increment updates the version file automatically"
    echo ""
}

# Parse command line arguments
parse_arguments() {
    COMMAND="release"
    COMPONENT="all"
    VERSION=""
    INCREMENT_TYPE="minor"
    REGISTRY="$DEFAULT_REGISTRY"
    RUN_TESTS=true
    CREATE_TAG=true
    CREATE_GITHUB_RELEASE=true
    PUSH_IMAGES=true
    DRY_RUN=false
    
    # Check if first argument is a command
    if [[ "$1" == "clean" ]]; then
        COMMAND="clean"
        return
    elif [[ "$1" == "release" ]]; then
        COMMAND="release"
        shift
    fi
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                if [[ -n "$2" && "$2" != -* ]]; then
                    VERSION="$2"
                    shift 2
                else
                    print_error "Option -v|--version requires a version argument"
                    exit 1
                fi
                ;;
            -i|--increment)
                if [[ -n "$2" && "$2" != -* ]]; then
                    INCREMENT_TYPE="$2"
                    shift 2
                else
                    print_error "Option -i|--increment requires a type argument"
                    exit 1
                fi
                ;;
            -r|--registry)
                if [[ -n "$2" && "$2" != -* ]]; then
                    REGISTRY="$2"
                    shift 2
                else
                    print_error "Option -r|--registry requires a registry argument"
                    exit 1
                fi
                ;;
            --no-tests)
                RUN_TESTS=false
                shift
                ;;
            --no-tag)
                CREATE_TAG=false
                shift
                ;;
            --no-github)
                CREATE_GITHUB_RELEASE=false
                shift
                ;;
            --no-push)
                PUSH_IMAGES=false
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                if [[ " ${COMPONENTS[*]} " =~ " $1 " ]]; then
                    COMPONENT="$1"
                else
                    print_error "Invalid component: $1"
                    echo "Valid components: ${COMPONENTS[*]}"
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# Show release plan
show_release_plan() {
    local current_version=$1
    local new_version=$2
    local component=$3
    
    print_header
    echo ""
    echo "üìã Release Plan"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "Component:    $component"
    echo "Current:      $current_version"
    echo "New:          $new_version"
    echo "Registry:     $REGISTRY"
    echo "Increment:    $INCREMENT_TYPE"
    echo "Dry Run:      $DRY_RUN"
    echo ""
    echo "Steps:"
    
    if [ "$RUN_TESTS" = true ]; then
        echo "  ‚úÖ Run tests"
    else
        echo "  ‚è≠Ô∏è  Skip tests"
    fi
    
    case $component in
        sdk)
            echo "  üì¶ Package SDK"
            echo "  üè∑Ô∏è  Create git tag"
            if [ "$CREATE_GITHUB_RELEASE" = true ]; then
                echo "  üöÄ Create GitHub release"
            fi
            ;;
        registry|executor|worker)
            echo "  üê≥ Build Docker image"
            echo "  ‚öôÔ∏è  Build binary"
            if [ "$PUSH_IMAGES" = true ]; then
                echo "  üì§ Push Docker image"
            fi
            echo "  üè∑Ô∏è  Create git tag"
            if [ "$CREATE_GITHUB_RELEASE" = true ]; then
                echo "  üöÄ Create GitHub release"
            fi
            ;;
        all)
            echo "  üì¶ Package SDK"
            echo "  üê≥ Build Docker images (registry, executor, worker)"
            echo "  ‚öôÔ∏è  Build binaries"
            echo "  üì¶ Create release bundle"
            echo "  üì¶ Create binaries archive"
            if [ "$PUSH_IMAGES" = true ]; then
                echo "  üì§ Push Docker images"
            fi
            echo "  üè∑Ô∏è  Create git tag"
            if [ "$CREATE_GITHUB_RELEASE" = true ]; then
                echo "  üöÄ Create GitHub release"
            fi
            ;;
    esac
    echo ""
}

# Main release function
release_component() {
    local component=$1
    local version=$2
    
    print_step "Starting Release: $component $version"
    
    # Determine which components to process
    local components_to_process=()
    case $component in
        sdk)
            components_to_process=("sdk")
            ;;
        registry|executor|worker)
            components_to_process=("$component")
            ;;
        all)
            components_to_process=("sdk" "registry" "executor" "worker")
            ;;
    esac
    
    # Run tests if enabled
    if [ "$RUN_TESTS" = true ] && [ "$DRY_RUN" = false ]; then
        run_tests
    fi
    
    # Process each component
    for comp in "${components_to_process[@]}"; do
        case $comp in
            sdk)
                if [ "$DRY_RUN" = false ]; then
                    release_sdk "$version" || return 1
                else
                    echo "[DRY RUN] Would release SDK $version"
                fi
                ;;
            registry|executor|worker)
                if [ "$DRY_RUN" = false ]; then
                    # Build Docker image
                    release_docker_component "$comp" "$version" "$REGISTRY" || return 1
                    
                    # Build binary
                    build_component_binary "$comp" "$version" || return 1
                else
                    echo "[DRY RUN] Would build Docker image: $REGISTRY/uwf-$comp:$version"
                    echo "[DRY RUN] Would build binary: dist/binaries-$version/$comp-service"
                fi
                ;;
        esac
    done
    
    # Create release bundle for "all" releases
    if [ "$component" = "all" ]; then
        if [ "$DRY_RUN" = false ]; then
            create_release_bundle "$version" "$REGISTRY" || return 1
            create_binaries_archive "$version" || return 1
        else
            echo "[DRY RUN] Would create release bundle: unified-workflow-stack-$version.tar.gz"
            echo "[DRY RUN] Would create binaries archive: dist/unified-workflow-binaries-$version.tar.gz"
        fi
    fi
    
    # Push Docker images if enabled
    if [ "$PUSH_IMAGES" = true ] && [ "$DRY_RUN" = false ]; then
        if [ "$component" = "all" ]; then
            push_docker_images "registry executor worker" "$version" "$REGISTRY" || return 1
        elif [ "$component" != "sdk" ]; then
            push_docker_images "$component" "$version" "$REGISTRY" || return 1
        fi
    fi
    
    # Create git tag if enabled
    if [ "$CREATE_TAG" = true ] && [ "$DRY_RUN" = false ]; then
        create_git_tag "$version" || return 1
    fi
    
    # Create GitHub release if enabled
    if [ "$CREATE_GITHUB_RELEASE" = true ] && [ "$DRY_RUN" = false ]; then
        create_github_release "$version" || return 1
    fi
    
    return 0
}

# Main execution
main() {
    # Parse arguments
    parse_arguments "$@"
    
    # Handle clean command
    if [ "$COMMAND" = "clean" ]; then
        clean_release_artifacts
        exit 0
    fi
    
    # Handle release command
    # Read current version
    CURRENT_VERSION=$(read_current_version)
    
    # Determine new version
    if [ -z "$VERSION" ]; then
        NEW_VERSION=$(increment_version "$CURRENT_VERSION" "$INCREMENT_TYPE")
        print_info "Auto-incrementing version: $CURRENT_VERSION ‚Üí $NEW_VERSION ($INCREMENT_TYPE)"
    else
        NEW_VERSION="$VERSION"
        # Validate version format
        if ! [[ $NEW_VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            print_error "Invalid version format: $NEW_VERSION. Expected format: vX.Y.Z"
            exit 1
        fi
    fi
    
    # Show release plan
    show_release_plan "$CURRENT_VERSION" "$NEW_VERSION" "$COMPONENT"
    
    if [ "$DRY_RUN" = true ]; then
        print_success "Dry run complete. No changes were made."
        echo ""
        echo "To execute this release, run:"
        echo "  ./release $COMPONENT -v $NEW_VERSION -r $REGISTRY"
        exit 0
    fi
    
    # Check prerequisites
    check_prerequisites
    
    # Confirm release
    echo ""
    read -p "Proceed with release? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_warning "Release cancelled by user"
        exit 0
    fi
    
    # Start release
    if release_component "$COMPONENT" "$NEW_VERSION"; then
        # Update version file if auto-incremented
        if [ -z "$VERSION" ]; then
            update_version_file "$NEW_VERSION"
        fi
        
        print_step "Release Complete"
        echo ""
        echo "üéâ Successfully released $COMPONENT $NEW_VERSION!"
        echo ""
        
        # Show release artifacts
        case $COMPONENT in
            sdk)
                echo "Release artifacts:"
                echo "  - dist/unified-workflow-sdk-${NEW_VERSION}.tar.gz"
                echo "  - dist/unified-workflow-sdk-${NEW_VERSION}.tar.gz.sha256"
                ;;
            registry|executor|worker)
                echo "Release artifacts:"
                echo "  - Docker image: $REGISTRY/uwf-$COMPONENT:$NEW_VERSION"
                echo "  - Binary: dist/binaries-$NEW_VERSION/$COMPONENT-service"
                ;;
            all)
                echo "Release artifacts:"
                echo "  - dist/unified-workflow-sdk-${NEW_VERSION}.tar.gz"
                echo "  - unified-workflow-stack-${NEW_VERSION}.tar.gz"
                echo "  - dist/unified-workflow-binaries-${NEW_VERSION}.tar.gz"
                echo "  - Docker images:"
                echo "    - $REGISTRY/uwf-registry:$NEW_VERSION"
                echo "    - $REGISTRY/uwf-executor:$NEW_VERSION"
                echo "    - $REGISTRY/uwf-worker:$NEW_VERSION"
                ;;
        esac
        
        echo ""
        echo "Next steps:"
        echo "  1. Verify the release artifacts"
        echo "  2. Test the released components"
        echo "  3. Update documentation if needed"
        echo "  4. Notify stakeholders"
        echo ""
        
    else
        print_error "Release failed"
        exit 1
    fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
